行为模式
----
- ## `本质`
    - 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，  
      它涉及算法与对象间职责的分配
- ## `特点`
    - 1.行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。
    - 2.由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。

- [职责链模式](#1)
- [命令模式](#2)
- [解释器模式](#3)
- [迭代器模式](#4)
- [中介者模式](#5)
- [备忘录模式](#6)
- [观察者模式](#7)
- [状态模式](#8)
- [策略模式](#9)
- [模板模式](#10)
- [访问者模式](#11)

- ## <i id="1"></i>`Chain of Responsibility 职责链模式`
-[Chain of Responsibility](https://github.com/yangleizhou/design-patterns/tree/master/03-behavioral/01-chain_responsibility.go)
    - 职责链模式用于分离不同职责，并且动态组合相关职责。请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合
    - 职责链模式包含如下角色：
        - Handler：抽象处理者角色，定义一个处理请求的接口，包含抽象处理方法和一个后继连接
        - ConcreteHandler：具体处理者角色，实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者
        - Client:客户端角色，创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程
    - 说明：在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了
    - 优点：1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息
            2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则
            3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任
            4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if··else语句
            5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则
    - 缺点：1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理
            2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响
            3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用
- ## <i id="2"></i>`Command 命令模式`
    - 将一个请求封装为一个对象，使发出请求的责任(行为请求者)和执行请求(行为实现者)的责任分割开
    - 命令模式包含如下角色：
        - Command：抽象命令类角色，声明执行命令的接口，拥有执行命令的抽象方法 execute()
        - ConcreteCommand：具体命令角色，抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作
        - Receiver：实现者/接收者角色，执行命令功能的相关操作，是具体命令对象业务的真正实现者
        - Invoker：调用者/请求者角色，是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者
    - 优点：1.降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
            2.增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
            3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
            4.方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复
    - 缺点：可能产生大量具体命令类。因为对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性
- ## <i id="3"></i>`Interpreter 解释器模式`
    - 解释器模式实现一个表达式接口，该接口解释一个特定的上下文。通常用于SQL解析和符号处理引擎
    - 解释器模式包含如下角色：
        - AbstractExpression：抽象表达式角色,定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
        - TerminalExpression：终结符表达式角色,是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
        - NonterminalExpression：非终结符表达式角色，也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
        - Context：环境角色，通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
        - Client:客户端，主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。
    - 优点：1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
            2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。
    - 缺点：1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
            2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
            3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。
- ## <i id="4"></i>`Iterator 迭代器模式`
    - 通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据
    - 迭代器模式包含如下角色：
        - Aggregate：抽象聚合角色，定义存储、添加、删除聚合对象以及创建迭代器对象的接口
        - ConcreteAggregate:具体聚合角色,实现抽象聚合类，返回一个具体迭代器的实例
        - Iterator:抽象迭代器角色,定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法
        - Concretelterator:具体迭代器角色,实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置
    - 说明：它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”
    - 优点：1.访问一个聚合对象的内容而无须暴露它的内部表示。
            2.遍历任务交由迭代器完成，这简化了聚合类。
            3.它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
            4.增加新的聚合类和迭代器类都很方便，无须修改原有代码。
            5.封装性良好，为遍历不同的聚合结构提供一个统一的接口
    - 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
- ## <i id="5"></i>`Mediator 中介者模式`
    - 中介者模式用一个中介对象来封装一系列对象交互，将多对多关联(网状结构)转换成一对多，构成星状结构
    - 中介者模式包含如下角色：
        - Mediator：抽象中介者角色,它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法
        - ConcreteMediator：具体中介者角色,实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色
        - Colleague：抽象同事类角色,定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能
        - ConcreteColleague：具体同事类角色,是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互
    - 说明：1.一个中介对象来封装一系列对象之间的交互,使原有对象之间的耦合松散，且可以独立地改变它们之间的交互.中介者模式又叫调停模式,它是迪米特法则  
           典型应用。
           2.中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。
           3.协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。
    - 优点：1.降低了对象之间的耦合性，使得对象易于独立地被复用
            2.将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展
            3.符合迪米特原则
    - 缺点：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护
- ## <i id="6"></i>`Memento 备忘录模式`
    - 在不破坏封装性的前提下,捕获一个对象的内部状态，并在对象之外保存这个状态,以便以后当需要时能将该对象恢复到原先保存的状态
    - 备忘录模式包含如下角色：
        - Originator：发起人角色,记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息
        - Memento:备忘录角色,负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人
        - Caretaker:管理者角色,对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改
    - 优点：1.提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态
            2.实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息
            3.发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则
    - 缺点：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源
- ## <i id="7"></i>`Observer 观察者模式`
    - 多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式
    - 观察者模式包含如下角色：
        - Subject：抽象主题角色，也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法
        - ConcreteSubject：具体主题角色，也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象
        - Observer：抽象观察者角色，它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用
        - ConcreteObserver：具体观察者角色,实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态
    - 说明：具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则
    - 优点：1.降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系
            2.目标与观察者之间建立了一套触发机制
    - 缺点：1.目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用
            2.观察者对象很多时，通知的发布会花费很多时间，影响程序的效率
- ## <i id="8"></i>`State 状态模式`
    - 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。
    - 状态模式包含如下角色：
        - Context：环境角色，也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
        - State：抽象状态角色,定义一个接口，用以封装环境对象中的特定状态所对应的行为
        - ConcreteState:具体状态角色,实现抽象状态所对应的行为
    - 说明：1.在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个  
            这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。
            2.减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
            3.有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。
    - 缺点：1.状态模式的使用必然会增加系统的类与对象的个数。
            2.状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
- ## <i id="9"></i>`Strategy 策略模式`
    - 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理,符合开闭原则。
    - 策略模式包含如下角色：
        - Strategy：抽象策略类，定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现
        - ConcreteStrategy：具体策略类，实现了抽象策略定义的接口，提供具体的算法实现
        - Context：环境类,持有一个策略类的引用，最终给客户端调用
    - 说明：策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。
    - 优点：1.多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
            2.策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
            3.策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
            4.策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
            5.策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。
    - 缺点：1.客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
            2.策略模式造成很多的策略类。
- ## <i id="10"></i>`Template 模板模式`
    - 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。
      模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现。使得实现符合开闭原则。
    - 模板模式包含如下角色：
        - AbstractClass：抽象类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下
            - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法
            - 基本方法：是整个算法中的一个步骤，包含以下几种类型
                - 抽象方法：在抽象类中申明，由具体子类实现
                - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它
                - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种
        - ConcreteClass：具体子类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤
    - 说明：1.模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。现在来介绍它们的基本结构。
    - 优点：1.它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
            2.它在父类中提取了公共的部分代码，便于代码复用。
            3.部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则
    - 缺点：1.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
            2.父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
- ## <i id="11"></i>`Visitor 访问者模式`
    - 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式
    - 访问者模式包含如下角色：
        - Visitor：抽象访问者角色,定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了             被访问的具体元素
        - ConcreteVisitor:具体访问者角色,实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
        - Element:抽象元素角色,声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
        - ConcreteElement:具体元素角色,实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素                    中可能还包含本身业务逻辑的相关操作。
        - ObjectStructure:对象结构角色,是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map                   等聚合类实现。
    - 优点：1.扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
            2.复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
            3.灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
            4.符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。
    - 缺点：1.增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开         闭原则”
            2.破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
            3.违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。
