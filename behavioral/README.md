行为模式
----
- ## `本质`
    - 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，  
      它涉及算法与对象间职责的分配
- ## `特点`
    - 1.行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。
    - 2.由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性
- ## `Chain of Responsibility 职责链模式`
    - 职责链模式用于分离不同职责，并且动态组合相关职责。请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合
    - 职责链模式包含如下角色：
        - Handler：抽象处理者角色，定义一个处理请求的接口，包含抽象处理方法和一个后继连接
        - ConcreteHandler：具体处理者角色，实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者
        - Client:客户端角色，创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程
    - 说明：在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了
    - 优点：1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息
            2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则
            3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任
            4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if··else语句
            5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则
    - 缺点：1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理
            2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响
            3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用
- ## `Command 命令模式`
    - 将一个请求封装为一个对象，使发出请求的责任(行为请求者)和执行请求(行为实现者)的责任分割开
    - 命令模式包含如下角色：
        - Command：抽象命令类角色，声明执行命令的接口，拥有执行命令的抽象方法 execute()
        - ConcreteCommand：具体命令角色，抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作
        - Receiver：实现者/接收者角色，执行命令功能的相关操作，是具体命令对象业务的真正实现者
        - Invoker：调用者/请求者角色，是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者
    - 优点：1.降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
            2.增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
            3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
            4.方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复
    - 缺点：可能产生大量具体命令类。因为对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性
- ## `Interpreter 解释器模式`
    - 解释器模式实现一个表达式接口，该接口解释一个特定的上下文。通常用于SQL解析和符号处理引擎
    - 解释器模式包含如下角色：
        - AbstractExpression：抽象表达式角色,定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
        - TerminalExpression：终结符表达式角色,是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
        - NonterminalExpression：非终结符表达式角色，也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
        - Context：环境角色，通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
        - Client:客户端，主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。
    - 优点：1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
            2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。
    - 缺点：1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
            2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
            3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。
- ## `Iterator 迭代器模式`
    - 在不改变现有对象结构情况下(在不影响其他对象的情况下),动态地给一个对象增加一些职责，即增加其额外的功能
- ## `Mediator 中介者模式`
    - 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问
- ## `Memento 备忘录模式`
    - 运用共享技术来有效地支持大量细粒度对象的复用
- ## `Observer 观察者模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `State 状态模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性 
- ## `Strategy 策略模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `Template 模板模式`
- ## `Visitor 访问者模式`

