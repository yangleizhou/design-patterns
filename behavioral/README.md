行为模式
----
- ## `本质`
    - 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，  
      它涉及算法与对象间职责的分配
- ## `特点`
    - 1.行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。
    - 2.由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性
- ## `Chain of Responsibility 职责链模式`
    - 职责链模式用于分离不同职责，并且动态组合相关职责。请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合
    - 职责链模式包含如下角色：
        - Handler：抽象处理者角色，定义一个处理请求的接口，包含抽象处理方法和一个后继连接
        - ConcreteHandler：具体处理者角色，实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者
        - Client:客户端角色，创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程
    - 说明：在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了
    - 优点：1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息
            2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则
            3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任
            4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if··else语句
            5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则
    - 缺点：1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理
            2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响
            3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用
- ## `Command 命令模式`
    - 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作
- ## `Interpreter 解释器模式`
    - 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度
- ## `Iterator 迭代器模式`
    - 在不改变现有对象结构情况下(在不影响其他对象的情况下),动态地给一个对象增加一些职责，即增加其额外的功能
- ## `Mediator 中介者模式`
    - 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问
- ## `Memento 备忘录模式`
    - 运用共享技术来有效地支持大量细粒度对象的复用
- ## `Observer 观察者模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `State 状态模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性 
- ## `Strategy 策略模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `Template 模板模式`
- ## `Visitor 访问者模式`

