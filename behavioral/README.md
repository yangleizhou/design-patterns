行为模式
----
- ## `本质`
    - 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，  
      它涉及算法与对象间职责的分配
- ## `特点`
    - 1.行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。
    - 2.由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性
- ## `Chain of Responsibility 职责链模式`
    - 职责链模式用于分离不同职责，并且动态组合相关职责。请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合
    - 职责链模式包含如下角色：
        - Handler：抽象处理者角色，定义一个处理请求的接口，包含抽象处理方法和一个后继连接
        - ConcreteHandler：具体处理者角色，实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者
        - Client:客户端角色，创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程
    - 说明：在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了
    - 优点：1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息
            2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则
            3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任
            4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if··else语句
            5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则
    - 缺点：1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理
            2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响
            3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用
- ## `Command 命令模式`
    - 将一个请求封装为一个对象，使发出请求的责任(行为请求者)和执行请求(行为实现者)的责任分割开
    - 命令模式包含如下角色：
        - Command：抽象命令类角色，声明执行命令的接口，拥有执行命令的抽象方法 execute()
        - ConcreteCommand：具体命令角色，抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作
        - Receiver：实现者/接收者角色，执行命令功能的相关操作，是具体命令对象业务的真正实现者
        - Invoker：调用者/请求者角色，是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者
    - 优点：1.降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
            2.增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
            3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
            4.方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复
    - 缺点：可能产生大量具体命令类。因为对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性
- ## `Interpreter 解释器模式`
    - 解释器模式实现一个表达式接口，该接口解释一个特定的上下文。通常用于SQL解析和符号处理引擎
    - 解释器模式包含如下角色：
        - AbstractExpression：抽象表达式角色,定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
        - TerminalExpression：终结符表达式角色,是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
        - NonterminalExpression：非终结符表达式角色，也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
        - Context：环境角色，通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
        - Client:客户端，主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。
    - 优点：1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
            2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。
    - 缺点：1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
            2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
            3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。
- ## `Iterator 迭代器模式`
    - 通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据
    - 迭代器模式包含如下角色：
        - Aggregate：抽象聚合角色，定义存储、添加、删除聚合对象以及创建迭代器对象的接口
        - ConcreteAggregate:具体聚合角色,实现抽象聚合类，返回一个具体迭代器的实例
        - Iterator:抽象迭代器角色,定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法
        - Concretelterator:具体迭代器角色,实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置
    - 说明：它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”
    - 优点：1.访问一个聚合对象的内容而无须暴露它的内部表示。
            2.遍历任务交由迭代器完成，这简化了聚合类。
            3.它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
            4.增加新的聚合类和迭代器类都很方便，无须修改原有代码。
            5.封装性良好，为遍历不同的聚合结构提供一个统一的接口
    - 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
- ## `Mediator 中介者模式`
    - 中介者模式用一个中介对象来封装一系列对象交互，将多对多关联(网状结构)转换成一对多，构成星状结构
    - 中介者模式包含如下角色：
        - Mediator：抽象中介者角色,它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法
        - ConcreteMediator：具体中介者角色,实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色
        - Colleague：抽象同事类角色,定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能
        - ConcreteColleague：具体同事类角色,是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互
    - 说明：一个中介对象来封装一系列对象之间的交互,使原有对象之间的耦合松散，且可以独立地改变它们之间的交互.中介者模式又叫调停模式,它是迪米特法则的典型应用。
    - 优点：1.降低了对象之间的耦合性，使得对象易于独立地被复用
            2.将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展
            3.符合迪米特原则
    - 缺点：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护
- ## `Memento 备忘录模式`
    - 运用共享技术来有效地支持大量细粒度对象的复用
- ## `Observer 观察者模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `State 状态模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性 
- ## `Strategy 策略模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `Template 模板模式`
- ## `Visitor 访问者模式`

