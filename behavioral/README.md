行为模式
----
- ## `本质`
    - 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，  
      它涉及算法与对象间职责的分配
- ## `特点`
    - 1.行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。
    - 2.由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性
- ## `Chain of Responsibility 职责链模式`
    - 职责链模式用于分离不同职责，并且动态组合相关职责。请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合
    - 职责链模式包含如下角色：
        - Handler：抽象处理者角色，定义一个处理请求的接口，包含抽象处理方法和一个后继连接
        - ConcreteHandler：具体处理者角色，实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者
        - Client:客户端角色，创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程
    - 说明：在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了
    - 优点：1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息
            2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则
            3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任
            4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if··else语句
            5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则
    - 缺点：1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理
            2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响
            3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用
- ## `Command 命令模式`
    - 将一个请求封装为一个对象，使发出请求的责任(行为请求者)和执行请求(行为实现者)的责任分割开
    - 职责链模式包含如下角色：
        - Command：抽象命令类角色，声明执行命令的接口，拥有执行命令的抽象方法 execute()
        - ConcreteCommand：具体命令角色，抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作
        - Receiver：实现者/接收者角色，执行命令功能的相关操作，是具体命令对象业务的真正实现者
        - Invoker：调用者/请求者角色，是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者
    - 优点：1.降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
            2.增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
            3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
            4.方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复
    - 缺点：可能产生大量具体命令类。因为对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性
- ## `Interpreter 解释器模式`
- ## `Iterator 迭代器模式`
    - 在不改变现有对象结构情况下(在不影响其他对象的情况下),动态地给一个对象增加一些职责，即增加其额外的功能
- ## `Mediator 中介者模式`
    - 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问
- ## `Memento 备忘录模式`
    - 运用共享技术来有效地支持大量细粒度对象的复用
- ## `Observer 观察者模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `State 状态模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性 
- ## `Strategy 策略模式`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
- ## `Template 模板模式`
- ## `Visitor 访问者模式`

