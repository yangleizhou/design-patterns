结构模式
----
- ## `本质`
    - 如何将类或对象按某种布局组成更大的结构
- ## `特点`
    - 1.它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象
    - 2.除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式
- ## `Proxy 代理模式`
    - 代理模式用于延迟处理操作或者在进行实际操作前后对真实对象进行其它处理
    - 代理模式包含如下角色：
        - Subject: 抽象主题类,通过接口或抽象类声明真实主题和代理对象实现的业务方法
        - RealSubject:真实主题类,实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象
        - Proxy: 代理类,提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能
    - 说明：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用
    - 缺点：1.在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢
            2.增加了系统的复杂度
- ## `Adapter 适配器`
    - 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作
    - 适配器模式包含如下角色：
        - Target: 目标接口，当前系统业务所期待的接口，它可以是抽象类或接口
        - Adaptee: 适配者类,当前系统业务所期待的接口，它可以是抽象类或接口
        - Adapter: 适配器类,它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者
    - 配器模式的形式分为：1.类的适配器模式 & 对象的适配器模式
                          2.前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些
    - 缺点：过多的使用适配器，会让系统非常零乱，不易整体进行把握
    - 类适配器模式：
        - 说明：类的适配器模式是把适配的类的API转换成为目标类的API
        - 缺点：高耦合，灵活性低(使用对象继承的方式，是静态的定义方式)
    - 对象适配器模式：
        - 说明：1.与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API
                2.与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类
        - 缺点：使用复杂,需要引入对象实例,特别是需要重新定义Adaptee行为时需要重新定义Adaptee的子类，并将适配器组合适配
- ## `Bridge 桥接`
    - 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度
- ## `Decorator 装饰`
    - 动态地给对象增加一些职责，即增加其额外的功能
- ## `Facade 外观`
    - 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问
- ## `Flyweight 享元`
    - 运用共享技术来有效地支持大量细粒度对象的复用
- ## `Composite 组合`
    - 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
